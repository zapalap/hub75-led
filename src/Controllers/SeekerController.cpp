#include "SeekerController.h"

const int SeekerController::sprites[256] = {
    // smiley
    0x00, 0xf0, 0x0f, 0x00, 0x00, 0xfe, 0x7f, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0xc0, 0x03, 0xc0, 0x03, 0xe0, 0x00, 0x00, 0x07, 0x70, 0x00, 0x00, 0x0e, 0x38, 0x00, 0x00, 0x1c, 0x18, 0x00, 0x00, 0x18,
    0x0c, 0x00, 0x00, 0x30, 0x0c, 0x00, 0x00, 0x30, 0x06, 0x00, 0x38, 0x60, 0x06, 0x00, 0x7c, 0x60, 0x06, 0x3f, 0xfc, 0x60, 0x06, 0x3f, 0xfc, 0x60, 0x03, 0x00, 0x7c, 0xc0, 0x03, 0x00, 0x38, 0xc0,
    0x03, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0xc0, 0x06, 0x00, 0x00, 0x60, 0x06, 0x00, 0x00, 0x60, 0x06, 0xff, 0xff, 0x60, 0x06, 0xff, 0xff, 0x60, 0x0c, 0x00, 0xc3, 0x30, 0x0c, 0x00, 0xc3, 0x30,
    0x18, 0x00, 0x63, 0x18, 0x38, 0x00, 0x66, 0x1c, 0x70, 0x00, 0x3e, 0x0e, 0xe0, 0x00, 0x3c, 0x07, 0xc0, 0x03, 0xc0, 0x03, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0xfe, 0x7f, 0x00, 0x00, 0xf0, 0x0f, 0x00,

    //mustache
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x01, 0x0c, 0x00, 0x00, 0x01, 0x08,
    0x00, 0x80, 0x01, 0x08, 0x00, 0x80, 0x01, 0x08, 0x00, 0x00, 0x01, 0x38, 0x00, 0x00, 0x01, 0x7c, 0x00, 0x00, 0x03, 0xc4, 0x00, 0x00, 0x06, 0x86, 0x00, 0x00, 0xfc, 0x81, 0x00, 0x00, 0x20, 0x80,
    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x18, 0x03, 0x80, 0x00, 0xfe, 0x0f, 0x80, 0x00, 0xff, 0x1f, 0x80, 0x80, 0xff, 0x3f, 0x80, 0xef, 0xff, 0xff, 0x9e,
    0xfe, 0xff, 0xff, 0x9f, 0xfe, 0xff, 0xff, 0x8f, 0xfc, 0xff, 0xff, 0x87, 0xf8, 0x1f, 0xff, 0x83, 0xf0, 0x07, 0xfc, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

};

SeekerController::SeekerController()
{
}

void SeekerController::enter(const FrameContext &frame)
{
    randomSeed(ESP.getCycleCount());
    for (Particle *seeker : seekers)
    {
        delete (seeker);
    }
    seekers.clear();
    targets.clear();
    int start = 128;
    Serial.println(String(start));
    for (int i = 0; i < 128; i++)
    {
        for (int b = 0; b < 8; b++)
        {
            int y = i / 4 + 1;
            int x = ((i % 4) * 8) + b + 16;
            int isSet = sprites[i + start] & (1 << b);
            if (isSet)
            {
                SeekTarget seekTarget;
                seekTarget.x = x;
                seekTarget.y = y;
                targets.push_back(seekTarget);
            }
            if (frame.matrix[y][x] > 0)
            {
                Particle *seeker = new Particle(0.5, 1, 0.8);
                seeker->location.x = x;
                seeker->location.y = y;
                seekers.push_back(seeker);
            }
        }
    }

    int missingSeekers = targets.size() - seekers.size();
    if (missingSeekers > 0)
    {
        for (int i = 0; i <= missingSeekers; i++)
        {
            Particle *seeker = new Particle(0.5, 1, 0.8);
            seeker->location.x = random(0, 63);
            seeker->location.y = random(0, 100) > 50 ? 0 : 31;
            seekers.push_back(seeker);
        }
    }
}

FrameContext SeekerController::update(const FrameContext &frame)
{
    clearMatrix(frame);
    int i = 0;
    int targetsSize = targets.size();
    if (targetsSize > 0)
    {
        for (Particle *seeker : seekers)
        {
            SeekTarget t = targets[i];
            Vector targetLoc((double)t.x, (double)t.y);

            if (seeker->distanceTo(targetLoc) < 3)
            {
                seeker->location.x = (double)t.x;
                seeker->location.y = (double)t.y;
            }
            else
            {
                seeker->seek(targetLoc);
                seeker->update(frame);
            }
            seeker->draw(frame);
            i++;
            if (i > targetsSize - 1)
            {
                i = 0;
            }
        }
    }

    FrameContext updatedContext(frame.matrix, frame.joyState, frame.selectButtonState);
    return updatedContext;
}

void SeekerController::clearMatrix(const FrameContext &frame)
{
    for (byte x = 0; x < 64; x++)
    {
        for (byte y = 0; y < 32; y++)
        {
            frame.matrix[y][x] = 0;
        }
    }
}

double SeekerController::limit(double value, int min, int max)
{
    if (value > max)
    {
        value = max;
        return value;
    }
    if (value < min)
    {
        value = min;
        return value;
    }
    return value;
}
